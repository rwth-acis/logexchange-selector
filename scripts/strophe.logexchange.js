// Generated by CoffeeScript 1.7.1
Strophe.addConnectionPlugin('logexchange', {
  _connection: null,

  /*Function
  Initialize the Logexchange plugin. Sets the correct connection object and
  extends the namesace.
   */
  init: function(conn) {
    var ns, _ref;
    this._connection = conn;
    this._allowed_jids = [];
    this._activated_domains = {};
    ns = "urn:xmpp:logexchange";
    Strophe.addNamespace('LOGEXCHANGE', ns);
    if (conn.disco) {
      if (conn.disco.addFeature != null) {
        conn.disco.addFeature(Strophe.NS.LOGEXCHANGE);
      }
      if (conn.disco.addNode) {
        conn.disco.addNode(Strophe.NS.LOGEXCHANGE, {
          items: [
            {
              node: 'logexchange/p2p',
              name: "Log p2p data"
            }
          ]
        });
      }
      if ((_ref = conn.cmds) != null ? _ref.add : void 0) {
        return conn.cmds.add({
          node: "logexchange/p2p",
          name: "Log p2p data"
        }, (function(_this) {
          return function(req, res) {
            var from, id;
            top.req = req;
            top.res = res;
            res.attrs({
              status: "completed"
            });
            from = req.attr("from");
            if (_this._allowed_jids.indexOf(Strophe.getBareJidFromJid(from)) >= 0) {
              id = _this._connection.getUniqueId();
              res.c('note', {
                type: "info"
              }, id);
            } else {
              res.c('note', {
                type: "error"
              }).up();
              res.c('error', {
                type: 'cancel'
              });
              res.c('forbidden', {
                xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'
              });
            }
            return res;
          };
        })(this));
      }
    }
  },
  allow_jid: function(jid) {
    var bjid;
    bjid = Strophe.getBareJidFromJid(jid);
    if (this._allowed_jids.indexOf(bjid) < 0) {
      return this._allowed_jids.push(bjid);
    }
  },
  allow_server: function() {
    return this.allow_jid(Strophe.getDomainFromJid(this._connection.jid));
  },
  request_stanzalogs: function(server, success, error) {
    var cmd, exec;
    cmd = new Strophe.Commands.RemoteCommand(this._connection, server, "logexchange/stanza");
    exec = {
      success: success || function(res, cmd) {
        var f, new_fields, resp;
        console.log(cmd.form.fields);
        new_fields = (function() {
          var _i, _len, _ref, _results;
          _ref = cmd.form.fields;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(new Strophe.x.Field({
              "var": f["var"],
              type: f.type,
              values: f.values
            }));
          }
          return _results;
        })();
        console.log(new_fields);
        resp = new Strophe.x.Form({
          type: "submit",
          fields: new_fields
        });
        return cmd.complete({
          responseForm: resp
        });
      },
      error: error || console.log
    };
    return {
      cmd: cmd,
      exec: exec,
      execute: cmd.execute(exec)
    };
  },
  new_stanzalog: function(server, callback, err_callback) {
    var cmd;
    if (typeof server === "function") {
      err_callback = callback;
      callback = server;
      server = this._connection.domain;
    }
    cmd = new Strophe.Commands.RemoteCommand(this._connection, server, "logexchange/stanza");
    cmd.execute({
      success: function(stanza, cmd) {
        return callback(stanza, cmd);
      },
      error: function(stanza, cmd) {
        return err_callback(stanza, cmd);
      }
    });
    return cmd;
  },
  new_statuslog: function(server, callback, err_callback) {
    var cmd;
    if (typeof server === "function") {
      err_callback = callback;
      callback = server;
      server = this._connection.domain;
    }
    cmd = new Strophe.Commands.RemoteCommand(this._connection, server, "logexchange/status");
    cmd.execute({
      success: function(stanza, cmd) {
        return callback(stanza, cmd);
      },
      error: function(stanza, cmd) {
        return err_callback(stanza, cmd);
      }
    });
    return cmd;
  },
  get_sessions: function(server, callback) {
    var cmd;
    if (typeof server === "function") {
      callback = server;
      server = this._connection.domain;
    }
    cmd = new Strophe.Commands.RemoteCommand(this._connection, server, "logexchange/list");
    return cmd.execute({
      success: function(stanza, cmd) {
        var sessions, st, types;
        sessions = [];
        types = [];
        st = $(stanza);
        st.find("command x field[var='sessions'] value").each(function(index) {
          return sessions.push(this.textContent);
        });
        st.find("command x field[var='types'] value").each(function(index) {
          return types.push(this.textContent);
        });
        return callback(sessions, types);
      },
      error: function() {
        return callback("Something went wrong");
      }
    });
  },
  stop_session: function(server, session_id, success, error) {
    var cmd;
    if (!session_id || typeof session_id === "function") {
      error = success;
      success = session_id;
      session_id = server;
      server = this._connection.domain;
    }
    cmd = new Strophe.Commands.RemoteCommand(this._connection, server, "logexchange/stop");
    return cmd.execute({
      success: function(stanza, cmd) {
        var resp;
        resp = new Strophe.x.Form({
          type: "submit",
          fields: [
            new Strophe.x.Field({
              "var": "logid",
              type: "text-single",
              values: [session_id]
            })
          ]
        });
        return cmd.complete({
          responseForm: resp,
          success: success,
          error: error
        });
      },
      error: function() {
        return callback("Something went wrong");
      }
    });
  },
  activate_p2p: function(server, callback) {
    var cmd, _ref;
    if (typeof server === "function") {
      callback = server;
    }
    if (server == null) {
      server = this._connection.domain;
    }
    if (((_ref = Strophe.Commands) != null ? _ref.RemoteCommand : void 0) != null) {
      cmd = new Strophe.Commands.RemoteCommand(this._connection, server, "logexchange/p2p");
    } else {
      cmd = {
        execute: (function(_this) {
          return function(cbs) {
            var iq;
            iq = $iq({
              to: server,
              type: "set"
            });
            iq.c("command", {
              xmlns: 'http://jabber.org/protocol/commands',
              node: 'logexchange/p2p',
              action: 'execute'
            });
            return _this._connection.sendIQ(iq, cbs.success, cbs.error);
          };
        })(this)
      };
    }
    return cmd.execute({
      success: (function(_this) {
        return function() {
          _this._activated_domains[server] = true;
          if (callback) {
            return callback(true);
          }
        };
      })(this),
      error: (function(_this) {
        return function() {
          if (callback) {
            return callback(false);
          }
        };
      })(this)
    });
  },
  log_stanza: function(stanza, to) {
    if (to == null) {
      to = this._connection.domain;
    }
    if (this._activated_domains[to]) {
      return this._connection.send(this._connection.eventlog.wrap_stanza(stanza, to));
    } else {
      return this.activate_p2p(to, (function(_this) {
        return function(success) {
          if (success) {
            return _this._connection.send(_this._connection.eventlog.wrap_stanza(stanza, to));
          }
        };
      })(this));
    }
  }
});
