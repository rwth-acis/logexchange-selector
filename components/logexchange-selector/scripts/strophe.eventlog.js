// Generated by CoffeeScript 1.7.1

/*
 *Plugin to implement the Eventlog extension.
   http://xmpp.org/extensions/xep-0337.html
 *Author:
    Andreas Guth <guth@dbis.rwth-aachen.de>
 */
var Eventlog;

Strophe.addConnectionPlugin('eventlog', {
  _connection: null,

  /*Function
  Initialize the Eventlog plugin. Sets the correct connection object and
  extends the namesace.
   */
  init: function(conn) {
    var ns;
    this._connection = conn;
    this._eventlog_handler = null;
    this._eventlog_handlers = {};
    this._eventlog_stanza_handlers = {};
    this._handler_ids = 1;
    ns = "urn:xmpp:eventlog";
    Strophe.addNamespace('EVENTLOG', ns);
    if (conn.disco) {
      if (conn.disco.addFeature != null) {
        conn.disco.addFeature(Strophe.NS.EVENTLOG);
      }
      if (conn.disco.addNode != null) {
        conn.disco.addNode(Strophe.NS.EVENTLOG, {
          items: []
        });
      }
    }
    if (this._eventlog_handler == null) {
      this._eventlog_handler = this._connection.addHandler((function(_this) {
        return function(stanza) {
          var handler, id, log, xquery, _i, _len, _ref, _ref1;
          xquery = stanza.getElementsByTagNameNS(ns, "log");
          if (xquery.length > 0) {
            _ref = _this._eventlog_stanza_handlers;
            for (id in _ref) {
              handler = _ref[id];
              handler(stanza);
            }
            for (_i = 0, _len = xquery.length; _i < _len; _i++) {
              log = xquery[_i];
              _ref1 = _this._eventlog_handlers;
              for (id in _ref1) {
                handler = _ref1[id];
                if (!handler(new Eventlog(log))) {
                  removeHandler(id);
                }
              }
            }
          }
          return true;
        };
      })(this), ns, "message");
    }
    return null;
  },
  addHandler: function(handler, stanza) {
    var id;
    if (stanza == null) {
      stanza = false;
    }
    id = this._handler_ids++;
    if (!stanza) {
      this._eventlog_handlers[id] = handler;
    } else {
      this._eventlog_stanza_handlers[id] = handler;
    }
    return id;
  },

  /*Function
  Removes an eventlog handler.
  This function takes ONLY ids returned by the addHandler function.
  Passing handler ids returned by connection.addHandler may brake things!
    Parameters:
  (number) id - the id of the handler
   */
  removeHandler: function(id) {
    delete this._eventlog_handlers[id];
    return delete this._eventlog_stanza_handlers[id];
  },

  /*Function
  Builds an Eventlog stanza.
  This function takes either each attribute as a paramater and a tags object
  or an object containing all attributus and a tags object
  (timestamp) timestamp - the timestamp of the event. Either an ISO string or a Date() object
  (string) id - the id of the event
  (string) type - the type of the event
  (string) level - the level of the event
  (string) object - the object of the event
  (string) subject - the subject of the event
  (string) facility - the facility of the event
  (string) module - the module of the event
  (object) tags - the tags as object in form tags[name] = {value:"", type:""}
                  OR an Array of tag DOM Builder Elements
  OR
  (object) attributes - the attributes as key/value object
  (object) tags - the tags as object in form tags[name] = {value:"", type:""}
                  OR an Array of tag DOM Builder Elements
   */
  build_log: function(message, timestamp, id, type, level, object, subject, facility, module, tags, stackTrace) {
    var attrs, log, name, tag, tattrs, _i, _len;
    attrs = {};
    if (timestamp.toISOString) {
      timestamp = timestamp.toISOString();
    } else if (timestamp.timestamp) {
      attrs = timestamp;
      if ((tags == null) && (typeof id) === "object") {
        tags = id;
      }
      if ((typeof type) === "string" && !stackTrace) {
        stackTrace = type;
      }
    } else {
      attrs.timestamp = timestamp;
      if (id != null) {
        attrs.id = id;
      }
      if (type != null) {
        attrs.type = type;
      }
      if (level != null) {
        attrs.level = level;
      }
      if (object != null) {
        attrs.object = object;
      }
      if (subject != null) {
        attrs.subject = subject;
      }
      if (facility != null) {
        attrs.facility = facility;
      }
      if (module != null) {
        attrs.module = module;
      }
    }
    attrs.xmlns = "urn:xmpp:eventlog";
    log = $build("log", attrs);
    if (typeof message === "object") {
      if (typeof message.tree === "function") {
        log.c("message").cnode(message.tree()).up();
      } else {
        log.c("message").cnode(message).up();
      }
    } else if (typeof message === "string") {
      log.c("message", null, message).up();
    } else {
      log.c("message", null, "").up();
    }
    if (tags != null ? tags.pop : void 0) {
      for (_i = 0, _len = tags.length; _i < _len; _i++) {
        tag = tags[_i];
        if (tag.tree != null) {
          log.cnode(tag).up();
        } else {
          tattrs = {
            name: tag.name,
            value: tag.value
          };
          if (tag.type != null) {
            tattrs.type = tag.type;
          }
          log.c("tag", tattrs).up();
        }
      }
    }
    for (name in tags) {
      tag = tags[name];
      tattrs = {
        name: name,
        value: tag.value
      };
      if (tag.type != null) {
        tattrs.type = tag.type;
      }
      log.c("tag", tattrs).up();
    }
    if (stackTrace != null) {
      log.c("stackTrace", null, stackTrace).up();
    }
    return log;
  },
  build_tag: function(name, value, type) {
    if (type == null) {
      type = "xs:string";
    }
    return $build("tag", {
      name: name,
      value: value,
      type: type
    });
  },
  build: function(attrs, logs) {
    var log, stanza, _i, _len;
    attrs["type"] = "normal";
    attrs["xml:lang"] = "en";
    stanza = $msg(attrs);
    if (logs instanceof Array) {
      for (_i = 0, _len = logs.length; _i < _len; _i++) {
        log = logs[_i];
        stanza.cnode(typeof log.tree === "function" ? log.tree() : log);
      }
    } else {
      stanza.cnode(typeof logs.tree === "function" ? logs.tree() : logs);
    }
    return stanza;
  },
  wrap_stanza: function(stanza, to) {
    var tree, _ref, _ref1;
    if (to == null) {
      to = this._connection.domain;
    }
    tree = stanza != null ? typeof stanza.tree === "function" ? stanza.tree() : void 0 : void 0;
    return this.build({
      to: to
    }, this.build_log(stanza, {
      timestamp: new Date(),
      subject: (tree != null ? (_ref = tree.attributes.from) != null ? _ref.textContent : void 0 : void 0) || this._connection.jid,
      object: (tree != null ? (_ref1 = tree.attributes.to) != null ? _ref1.textContent : void 0 : void 0) || this.connection.domain
    }));
  }
});

Eventlog = (function() {
  function Eventlog(log) {
    var attrs, stackquery, tag, tagquery, tattrs, type, value, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    attrs = log.attributes;
    this.timestamp = new Date(((_ref = attrs["timestamp"]) != null ? _ref.textContent : void 0) || null);
    this.id = (_ref1 = attrs.id) != null ? _ref1.textContent : void 0;
    this.type = ((_ref2 = attrs.type) != null ? _ref2.textContent : void 0) || "Informational";
    this.level = ((_ref3 = attrs.level) != null ? _ref3.textContent : void 0) || "Minor";
    this.object = (_ref4 = attrs.object) != null ? _ref4.textContent : void 0;
    this.subject = (_ref5 = attrs.subject) != null ? _ref5.textContent : void 0;
    this.facility = (_ref6 = attrs.facility) != null ? _ref6.textContent : void 0;
    this.module = (_ref7 = attrs.module) != null ? _ref7.textContent : void 0;
    this.tags = {};
    tagquery = log.getElementsByTagName("tag");
    if (tagquery.length > 0) {
      for (_i = 0, _len = tagquery.length; _i < _len; _i++) {
        tag = tagquery[_i];
        tattrs = tag.attributes;
        value = tattrs["value"].textContent;
        type = ((_ref8 = tattrs["type"]) != null ? _ref8.textContent : void 0) || "xs:string";
        switch (type) {
          case "xs:int":
          case "xs:byte":
          case "xs:integer":
          case "xs:long":
          case "xs:short":
            value = parseInt(value);
            break;
          case "xs:decimal":
          case "xs:double":
            value = parseFloat(value);
        }
        this.tags[tattrs["name"].textContent] = {
          value: value,
          type: type
        };
      }
    }
    stackquery = log.getElementsByTagName("stackTrace");
    if (stackquery.length > 0) {
      this.stackTrace = tagquery[0].textContent;
    }
    this.message = (_ref9 = log.getElementsByTagName("message")) != null ? _ref9[0].textContent : void 0;
  }

  Eventlog.prototype.toXML = function() {
    var attrs, log, name, tag, _ref;
    attrs = {};
    attrs["timestamp"] = this.timestamp.toISOString();
    if (this.id != null) {
      attrs["id"] = this.id;
    }
    if (this.type != null) {
      attrs["type"] = this.type;
    }
    if (this.level != null) {
      attrs["level"] = this.level;
    }
    if (this.object != null) {
      attrs["object"] = this.object;
    }
    if (this.subject != null) {
      attrs["subject"] = this.subject;
    }
    if (this.facility != null) {
      attrs["facility"] = this.facility;
    }
    if (this.module != null) {
      attrs["module"] = this.module;
    }
    log = $build("log", attrs);
    log.c("message", null, this.message).up();
    _ref = this.tags;
    for (name in _ref) {
      tag = _ref[name];
      log.c("tag", {
        name: name,
        value: tag.value,
        type: tag.type
      }).up();
    }
    if (this.stackTrace != null) {
      log.c("stackTrace", null, this.stackTrace).up();
    }
    return log;
  };

  return Eventlog;

})();
